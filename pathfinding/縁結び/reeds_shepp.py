import math
from utils import *
from .pathsegment import *
from .path_algo import PathAlgo

class RS(PathAlgo):

    def change_of_basis(self, p1, p2):
        """
        Given p1 = (x1, y1, theta1) and p2 = (x2, y2, theta2) represented in a
        coordinate system with origin (0, 0) and rotation 0 (in degrees), return
        the position and rotation of p2 in the coordinate system which origin
        (x1, y1) and rotation theta1.
        """
        theta1 = deg2rad(p1[2])
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        new_x = dx * math.cos(theta1) + dy * math.sin(theta1)
        new_y = -dx * math.sin(theta1) + dy * math.cos(theta1)
        new_theta = p2[2] - p1[2]
        return new_x, new_y, new_theta

    def timeflip(self, path):
        new_path = [e.reverse_gear() for e in path]
        return new_path


    def reflect(self, path):
        new_path = [e.reverse_steering() for e in path]
        return new_path
    
    def path_length(self, path):
        return sum([e.dist for e in path])

    def get_shortest_path(self, start, end):
        """
        Return the shortest path from start to end among those that exist
        """
        paths = self.get_all_paths(start, end)
        return min(paths, key=self.path_length)

    def get_all_paths(self, start, end):
        """
        Return a list of all the paths from start to end generated by the
        12 functions and their variants
        """
        path_fns = [self.path1, self.path2, self.path3, self.path4, self.path5,\
                    self.path6, self.path7, self.path8, self.path9, self.path10,\
                    self.path11, self.path12]
        paths = []

        # get coordinates of end in the set of axis where start is (0,0,0)
        x, y, theta = self.change_of_basis(start, end)

        for get_path in path_fns:
            # get the four variants for each path type, cf article
            paths.append(get_path(x, y, theta))
            paths.append(self.timeflip(get_path(-x, y, -theta)))
            paths.append(self.reflect(get_path(x, -y, -theta)))
            paths.append(self.reflect(self.timeflip(get_path(-x, -y, theta))))

        # remove path elements that have parameter 0
        for i in range(len(paths)):
            paths[i] = list(filter(lambda e: e.dist != 0, paths[i]))

        # remove empty paths
        paths = list(filter(None, paths))

        return paths


    def path1(self, x, y, phi):
        """
        Formula 8.1: CSC (same turns)
        """
        phi = deg2rad(phi)
        path = []

        u, t = R(x - math.sin(phi), y - 1 + math.cos(phi))
        v = M(phi - t)

        path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
        path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.FORWARD))
        path.append(PathSegment.create(v, Direction.LEFT, Gear.FORWARD))

        return path


    def path2(self, x, y, phi):
        """
        Formula 8.2: CSC (opposite turns)
        """
        phi = M(deg2rad(phi))
        path = []

        rho, t1 = R(x + math.sin(phi), y - 1 - math.cos(phi))

        if rho * rho >= 4:
            u = math.sqrt(rho * rho - 4)
            t = M(t1 + math.atan2(2, u))
            v = M(t - phi)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.FORWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.FORWARD))

        return path


    def path3(self, x, y, phi):
        """
        Formula 8.3: C|C|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x - math.sin(phi)
        eta = y - 1 + math.cos(phi)
        rho, theta = R(xi, eta)

        if rho <= 4:
            A = math.acos(rho / 4)
            t = M(theta + math.pi/2 + A)
            u = M(math.pi - 2*A)
            v = M(phi - t - u)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.LEFT, Gear.FORWARD))

        return path


    def path4(self, x, y, phi):
        """
        Formula 8.4 (1): C|CC
        """
        phi = deg2rad(phi)
        path = []

        xi = x - math.sin(phi)
        eta = y - 1 + math.cos(phi)
        rho, theta = R(xi, eta)

        if rho <= 4:
            A = math.acos(rho / 4)
            t = M(theta + math.pi/2 + A)
            u = M(math.pi - 2*A)
            v = M(t + u - phi)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.LEFT, Gear.BACKWARD))

        return path


    def path5(self, x, y, phi):
        """
        Formula 8.4 (2): CC|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x - math.sin(phi)
        eta = y - 1 + math.cos(phi)
        rho, theta = R(xi, eta)

        if rho <= 4:
            u = math.acos(1 - rho*rho/8)
            A = math.asin(2 * math.sin(u) / rho)
            t = M(theta + math.pi/2 - A)
            v = M(t - u - phi)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.RIGHT, Gear.FORWARD))
            path.append(PathSegment.create(v, Direction.LEFT, Gear.BACKWARD))

        return path


    def path6(self, x, y, phi):
        """
        Formula 8.7: CCu|CuC
        """
        phi = deg2rad(phi)
        path = []

        xi = x + math.sin(phi)
        eta = y - 1 - math.cos(phi)
        rho, theta = R(xi, eta)

        if rho <= 4:
            if rho <= 2:
                A = math.acos((rho + 2) / 4)
                t = M(theta + math.pi/2 + A)
                u = M(A)
                v = M(phi - t + 2*u)
            else:
                A = math.acos((rho - 2) / 4)
                t = M(theta + math.pi/2 - A)
                u = M(math.pi - A)
                v = M(phi - t + 2*u)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.RIGHT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.LEFT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.BACKWARD))

        return path


    def path7(self, x, y, phi):
        """
        Formula 8.8: C|CuCu|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x + math.sin(phi)
        eta = y - 1 - math.cos(phi)
        rho, theta = R(xi, eta)
        u1 = (20 - rho*rho) / 16

        if rho <= 6 and 0 <= u1 <= 1:
            u = math.acos(u1)
            A = math.asin(2 * math.sin(u) / rho)
            t = M(theta + math.pi/2 + A)
            v = M(t - phi)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(u, Direction.LEFT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.FORWARD))

        return path


    def path8(self, x, y, phi):
        """
        Formula 8.9 (1): C|C[pi/2]SC
        """
        phi = deg2rad(phi)
        path = []

        xi = x - math.sin(phi)
        eta = y - 1 + math.cos(phi)
        rho, theta = R(xi, eta)

        if rho >= 2:
            u = math.sqrt(rho*rho - 4) - 2
            A = math.atan2(2, u+2)
            t = M(theta + math.pi/2 + A)
            v = M(t - phi + math.pi/2)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(math.pi/2, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.LEFT, Gear.BACKWARD))

        return path


    def path9(self, x, y, phi):
        """
        Formula 8.9 (2): CSC[pi/2]|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x - math.sin(phi)
        eta = y - 1 + math.cos(phi)
        rho, theta = R(xi, eta)

        if rho >= 2:
            u = math.sqrt(rho*rho - 4) - 2
            A = math.atan2(u+2, 2)
            t = M(theta + math.pi/2 - A)
            v = M(t - phi - math.pi/2)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.FORWARD))
            path.append(PathSegment.create(math.pi/2, Direction.RIGHT, Gear.FORWARD))
            path.append(PathSegment.create(v, Direction.LEFT, Gear.BACKWARD))

        return path


    def path10(self, x, y, phi):
        """
        Formula 8.10 (1): C|C[pi/2]SC
        """
        phi = deg2rad(phi)
        path = []

        xi = x + math.sin(phi)
        eta = y - 1 - math.cos(phi)
        rho, theta = R(xi, eta)

        if rho >= 2:
            t = M(theta + math.pi/2)
            u = rho - 2
            v = M(phi - t - math.pi/2)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(math.pi/2, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.BACKWARD))

        return path


    def path11(self, x, y, phi):
        """
        Formula 8.10 (2): CSC[pi/2]|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x + math.sin(phi)
        eta = y - 1 - math.cos(phi)
        rho, theta = R(xi, eta)

        if rho >= 2:
            t = M(theta)
            u = rho - 2
            v = M(phi - t - math.pi/2)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.FORWARD))
            path.append(PathSegment.create(math.pi/2, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.BACKWARD))

        return path


    def path12(self, x, y, phi):
        """
        Formula 8.11: C|C[pi/2]SC[pi/2]|C
        """
        phi = deg2rad(phi)
        path = []

        xi = x + math.sin(phi)
        eta = y - 1 - math.cos(phi)
        rho, theta = R(xi, eta)

        if rho >= 4:
            u = math.sqrt(rho*rho - 4) - 4
            A = math.atan2(2, u+4)
            t = M(theta + math.pi/2 + A)
            v = M(t - phi)

            path.append(PathSegment.create(t, Direction.LEFT, Gear.FORWARD))
            path.append(PathSegment.create(math.pi/2, Direction.RIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(u, Direction.STRAIGHT, Gear.BACKWARD))
            path.append(PathSegment.create(math.pi/2, Direction.LEFT, Gear.BACKWARD))
            path.append(PathSegment.create(v, Direction.RIGHT, Gear.FORWARD))

        return path